<!DOCTYPE html>
<html lang="en">

<head>
  <title>Solar Activity</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Real-time solar activity monitoring with ISN, solar flux, and K-index data">
  <meta name="theme-color" content="#0f172a">
  <!-- Load Plotly.js from CDN -->
  <script src="https://cdn.plot.ly/plotly-3.1.0.min.js"></script>
  <!-- Load our custom CSS -->
  <link rel="stylesheet" href="{{ url_for('static', path='styles.css') }}">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;600;700&family=JetBrains+Mono&display=swap"
    rel="stylesheet">
  <!-- Add some icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>

<body>
  <header>
    <h1>
      <i class="fas fa-sun" aria-hidden="true"></i>
      Solar Activity
    </h1>
    <p class="description">
      Real-time monitoring of solar activity and geomagnetic conditions
    </p>
  </header>

  <main class="container">
    <!-- Solar Cycle Prediction Image -->
    <section class="graph-card" aria-labelledby="solar-cycle-title">
      <h2 id="solar-cycle-title">
        <i class="fas fa-chart-line" aria-hidden="true"></i>
        Solar Cycle Prediction
      </h2>
      <div class="solar-cycle-img-container">
        <img src="{{ solar_cycle_image }}" alt="Current solar cycle prediction chart showing sunspot activity trends"
          class="solar-cycle-img" loading="lazy">
      </div>
    </section>

    <section class="graph-card" aria-labelledby="kp-title">
      <h2 id="kp-title">
        <i class="fas fa-chart-line" aria-hidden="true"></i>
        Planetary K-Index
      </h2>
      <div id="kp-graph" class="graph-container" role="img"
        aria-label="Interactive chart showing planetary K-index measurements over time"></div>
    </section>

    <section class="graph-card" aria-labelledby="flux-title">
      <h2 id="flux-title">
        <i class="fas fa-chart-line" aria-hidden="true"></i>
        10.7cm Solar Flux
      </h2>
      <div id="flux-graph" class="graph-container" role="img"
        aria-label="Interactive chart showing 10.7cm solar flux measurements over time"></div>
    </section>

    <section class="graph-card" aria-labelledby="isn-title">
      <h2 id="isn-title">
        <i class="fas fa-chart-line" aria-hidden="true"></i>
        International Sunspot Number (ISN)
      </h2>
      <div id="isn-graph" class="graph-container" role="img"
        aria-label="Interactive chart showing International Sunspot Number measurements over time"></div>
    </section>

  </main>

  <footer>
    <p>
      <i class="fas fa-database" aria-hidden="true"></i>
      Data source:
      <a href="https://services.swpc.noaa.gov/" target="_blank" rel="noopener noreferrer">
        NOAA Space Weather Prediction Center
        <i class="fas fa-external-link-alt" aria-hidden="true"></i>
      </a>
    </p>
  </footer>

  <script type="application/json"
    id="solar-data">{{ solar_data | default({'dates': [], 'isn': [], 'flux': [], 'kp': [], 'kp_points': [], 'kp_dates': [], 'kp_daily': []}) | tojson }}</script>
  <script type="application/json" id="solar-error">{{ error_message | default(None) | tojson }}</script>

  <script>
    const parseJson = (elementId, fallback) => {
      try {
        const el = document.getElementById(elementId);
        if (!el) {
          return fallback;
        }
        const text = el.textContent ? el.textContent.trim() : '';
        return text ? JSON.parse(text) : fallback;
      } catch (error) {
        console.error(`Failed to parse JSON for ${elementId}:`, error);
        return fallback;
      }
    };

    const solarData = parseJson('solar-data', { dates: [], isn: [], flux: [], kp: [] });
    const errorMessage = parseJson('solar-error', null);

    const ensureArray = (value) => Array.isArray(value) ? value : [];

    const dates = ensureArray(solarData.dates);
    const isnValues = ensureArray(solarData.isn);
    const fluxValues = ensureArray(solarData.flux);
    const kpDates = ensureArray(solarData.kp_dates ?? solarData.kpDates ?? []);
    const kpValues = ensureArray(solarData.kp_daily ?? solarData.kp);
    const kpPointValues = ensureArray(solarData.kp_points)
      .filter((point) => point && point.timestamp && typeof point.value === 'number')
      .map((point) => ({
        timestamp: point.timestamp,
        value: point.value
      }));

    const normalizedData = {
      dates,
      isn: isnValues,
      flux: fluxValues,
      kpDaily: kpValues,
      kpDates,
      kpPoints: kpPointValues
    };
    console.log('Normalized solar data', normalizedData);
    if (errorMessage) {
      console.error('Solar data error message', errorMessage);
    }

    const showNoDataMessage = (message) => {
      addAlertStyles();

      const alertHtml = `
        <div class="alert alert-error">
          <h3>⚠️ No Data Available</h3>
          <p>${message}</p>
          <p>Try refreshing the page in a few minutes.</p>
        </div>
      `;

      document.body.insertAdjacentHTML('afterbegin', alertHtml);
    };

    const makeLayout = (title, yTitle) => ({
      title: {
        text: title,
        font: {
          family: 'Roboto, sans-serif',
          size: 20,
          color: '#0f172a'
        }
      },
      xaxis: {
        title: {
          text: 'Date',
          font: { family: 'Roboto, sans-serif', size: 14, color: '#64748b' }
        },
        tickangle: -45,
        tickfont: { family: 'Roboto, sans-serif', size: 12, color: '#475569' },
        gridcolor: '#e2e8f0',
        linecolor: '#cbd5e1'
      },
      yaxis: {
        title: {
          text: yTitle,
          font: { family: 'Roboto, sans-serif', size: 14, color: '#64748b' }
        },
        tickfont: { family: 'Roboto, sans-serif', size: 12, color: '#475569' },
        gridcolor: '#e2e8f0',
        linecolor: '#cbd5e1'
      },
      margin: { l: 60, r: 40, t: 80, b: 100 },
      hovermode: 'closest',
      paper_bgcolor: 'rgba(255,255,255,0)',
      plot_bgcolor: 'rgba(255,255,255,0)',
      dragmode: false,
      hoverlabel: {
        bgcolor: '#0f172a',
        bordercolor: '#e2e8f0',
        font: { family: 'Roboto, sans-serif', size: 12, color: '#f8fafc' }
      }
    });

    const makeTrace = (name, values, color) => ({
      name,
      x: normalizedData.dates,
      y: values,
      mode: 'lines+markers',
      type: 'scatter',
      line: { color: '#f59e0b', width: 3 },
      marker: { color: '#f59e0b', size: 6, line: { color: '#d97706', width: 1 } },
      hovertemplate: '%{y}<br>%{x}<extra></extra>'
    });

    if (normalizedData.dates.length === 0) {
      const message = errorMessage ?? 'Could not retrieve solar activity data from NOAA APIs. Please check the server logs for details.';
      console.error(message);
      showNoDataMessage(message);
    } else {
      Plotly.newPlot(
        'isn-graph',
        [makeTrace('ISN', normalizedData.isn, '#1F77B4')],
        makeLayout('ISN (from Flux proxy)', 'ISN'),
        {
          displayModeBar: false,
          modeBarButtons: [],
          scrollZoom: false,
          doubleClick: false,
          showTips: false,
          responsive: true,
          dragmode: false,
          select2d: false,
          lasso2d: false,
          editable: false,
          staticPlot: false
        }
      );

      Plotly.newPlot(
        'flux-graph',
        [makeTrace('10.7cm Flux', normalizedData.flux, '#1F77B4')],
        makeLayout('10.7cm Solar Flux', 'Flux (sfu)'),
        {
          displayModeBar: false,
          modeBarButtons: [],
          scrollZoom: false,
          doubleClick: false,
          showTips: false,
          responsive: true,
          dragmode: false,
          select2d: false,
          lasso2d: false,
          editable: false,
          staticPlot: false
        }
      );

      const kpLayout = makeLayout('Planetary K-index', 'Kp');
      kpLayout.yaxis = {
        title: {
          text: 'Kp',
          font: { family: 'Roboto, sans-serif', size: 14, color: '#64748b' }
        },
        range: [0, 9],
        tickfont: { family: 'Roboto, sans-serif', size: 12, color: '#475569' },
        gridcolor: '#e2e8f0',
        linecolor: '#cbd5e1'
      };

      const measurementTimes = normalizedData.kpPoints
        .map((point) => new Date(point.timestamp))
        .filter((dateObj) => !Number.isNaN(dateObj.getTime()));

      const sixHoursMs = 6 * 60 * 60 * 1000;
      let kpRangeStart = null;
      let kpRangeEnd = null;

      const formatDateTime = (dateObj) => {
        if (!dateObj) {
          return null;
        }
        const pad = (value) => String(value).padStart(2, '0');
        const year = dateObj.getFullYear();
        const month = pad(dateObj.getMonth() + 1);
        const day = pad(dateObj.getDate());
        const hours = pad(dateObj.getHours());
        const minutes = pad(dateObj.getMinutes());
        const seconds = pad(dateObj.getSeconds());
        return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}`;
      };

      if (measurementTimes.length > 0) {
        measurementTimes.sort((a, b) => a - b);
        const earliestMeasurement = measurementTimes[0];
        const latestMeasurement = measurementTimes[measurementTimes.length - 1];
        const proposedStart = new Date(latestMeasurement.getTime() - sixHoursMs);
        kpRangeStart = proposedStart;
        kpRangeEnd = latestMeasurement;
      } else if (normalizedData.kpDates.length > 0) {
        const parseDate = (value) => {
          const parsed = new Date(value);
          return Number.isNaN(parsed.getTime()) ? null : parsed;
        };
        const firstDate = parseDate(normalizedData.kpDates[0]);
        const lastDate = parseDate(normalizedData.kpDates[normalizedData.kpDates.length - 1]);
        if (firstDate && lastDate) {
          const proposedStart = new Date(lastDate.getTime() - sixHoursMs);
          kpRangeStart = proposedStart;
          kpRangeEnd = lastDate;
        }
      }

      kpLayout.xaxis.type = 'date';
      if (kpRangeStart && kpRangeEnd) {
        const formattedStart = formatDateTime(kpRangeStart);
        const formattedEnd = formatDateTime(kpRangeEnd);
        if (formattedStart && formattedEnd) {
          kpLayout.xaxis.range = [formattedStart, formattedEnd];
        }
      }

      if (kpRangeStart && kpRangeEnd) {
        const formattedStart = formatDateTime(kpRangeStart);
        const formattedEnd = formatDateTime(kpRangeEnd);
        if (formattedStart && formattedEnd) {
          kpLayout.shapes = [{
            type: 'line',
            x0: formattedStart,
            x1: formattedEnd,
            y0: 5,
            y1: 5,
            line: { color: '#ef4444', width: 2, dash: 'dash' },
            opacity: 0.7
          }];
        }
      }

      const kpAverageByDate = normalizedData.kpDates.reduce((acc, date, index) => {
        acc[date] = normalizedData.kpDaily[index];
        return acc;
      }, {});

      const kpAverageSeries = normalizedData.kpPoints
        .map((point) => {
          const dateKey = point.timestamp.split('T')[0];
          const avg = kpAverageByDate[dateKey];
          return avg !== undefined ? { timestamp: point.timestamp, value: avg } : null;
        })
        .filter(Boolean);

      const kpPointsTrace = {
        name: 'Kp Measurements',
        x: normalizedData.kpPoints.map((point) => point.timestamp),
        y: normalizedData.kpPoints.map((point) => point.value),
        mode: 'lines+markers',
        line: { color: '#f59e0b', width: 2, shape: 'linear' },
        type: 'scatter',
        marker: { color: '#f59e0b', size: 6, opacity: 0.8, line: { color: '#d97706', width: 1 } },
        hovertemplate: 'Kp %{y}<br>%{x}<extra></extra>'
      };

      Plotly.newPlot(
        'kp-graph',
        [kpPointsTrace],
        kpLayout,
        {
          displayModeBar: false,
          modeBarButtons: [],
          scrollZoom: false,
          doubleClick: false,
          showTips: false,
          responsive: true,
          dragmode: false,
          select2d: false,
          lasso2d: false,
          editable: false,
          staticPlot: false
        }
      );
    }

    // Disable any remaining interactivity
    setTimeout(() => {
      ['isn-graph', 'flux-graph', 'kp-graph'].forEach((id) => {
        const element = document.getElementById(id);
        if (element) {
          // Force update the config to disable all interactivity
          Plotly.update(element, {}, {}, {
            displayModeBar: false,
            modeBarButtons: [],
            scrollZoom: false,
            doubleClick: false,
            showTips: false,
            responsive: true,
            dragmode: false,
            select2d: false,
            lasso2d: false,
            editable: false,
            staticPlot: false
          });

          // Add CSS to disable pointer events on plot area
          const plotArea = element.querySelector('.plot');
          if (plotArea) {
            plotArea.style.pointerEvents = 'none';
          }

          // Re-enable pointer events for hover layer
          const hoverLayer = element.querySelector('.hoverlayer');
          if (hoverLayer) {
            hoverLayer.style.pointerEvents = 'auto';
          }
        }
      });
    }, 100);

    window.addEventListener('resize', () => {
      ['isn-graph', 'flux-graph', 'kp-graph'].forEach((id) => {
        const element = document.getElementById(id);
        if (element && element.data && element.data.length) {
          Plotly.Plots.resize(element);
        }
      });
    });
  </script>
</body>

</html>